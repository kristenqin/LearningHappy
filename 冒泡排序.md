# 冒泡排序

## 算法分解

1. 初始状态

   ==![image-20211108091458337](D:\CPrograming\MyPic\image-20211108091458337.png)==

2. 第一趟排序完成

   ==![冒泡排序第一趟](D:\CPrograming\MyPic\冒泡排序第一趟.gif)==

   最大的泡在最下

3. 之后的每次排序对剩下的数字进行排序

## 伪代码分解

**初始代码**

![image-20211108092419378](D:\CPrograming\MyPic\image-20211108092419378.png)

存在问题: 如果出现排序进行到某个阶段时, 序列已经到一个有序状态, 程序还会继续运行下去

此情况对应的判断条件:

走到某一趟排序时, 序列中没有任何一对元素需要交换位置, 用`flag`标记函数`swap`的执行状态

**完善代码**

![image-20211108092915393](D:\CPrograming\MyPic\image-20211108092915393.png)



## 时间复杂度

最好: 最开始是顺序 `O(n) `即可跳出循环

最坏: 整个数组是逆序, `n-1` 趟排序必须走完,  `O(n^2)`的时间复杂度是不可接受的

冒泡排序好处:

1. 简单
2. 对于单向链表中的元素进行排序比较方便, 这个是其他算法不能比的

排序算法稳定的保证:

1. 只对数组中两个相邻元素不相等时进行比较后排序
2. 相等的时候不进行排序

```c++
//稳定性概念
排序前两个相等的数 在序列中的前后位置顺序 和排序后它们两个的前后位置相同.
如原序列中r[i]=r[j], 且r[i]在r[j]之前, 而在排序后的序列中, r[i]仍在r[j]之前, 
则称这种排序算法是稳定的, 否则称为不稳定的.
```

```c++
//稳定性意义
如果要排序的内容原本的初始顺序存在意义, 那么需要稳定性的算法, 使得在二次排序的基础上保持原有的排序,
如果不需要保持初始的排序意义, 那么使用稳定性算法将毫无意义.

例如: 排序的内容是一组按照价格高低排序的对象, 如今需要按照销量高低排序, 使用稳定性算法, 
可以使相同销量的对象依然保持价格高低的排序, 只有销量不同的才会重新排序.
(这个案例里面是将价格作为数组的下标吗)
```



## 代码

```c++
//手写
#include<iostream>
void 
int main(){
    
}
```



